#include <Arduino.h>
#include <U8g2lib.h>
#include <SPI.h>
#include <Wire.h>

U8G2_SSD1309_128X64_NONAME0_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 10, /* dc=*/ 9, /* reset=*/ 8);  

const int SPLASH_W = 80;
const int SPLASH_H = 50;

// 'canvas', 81x45px
const unsigned char splash [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1F, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 
  0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x07, 0xFC, 0x7F, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x01, 0xF0, 0x7F, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xFC, 0x00, 0xE0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x7E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7F, 
  0x00, 0x80, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F, 0x00, 0x80, 
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0x00, 0x00, 0xFF, 0x01, 
  0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0x00, 0x00, 0xFF, 0x01, 0x00, 0x00, 
  0x00, 0x00, 0xC0, 0x3F, 0x00, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 
  0xC0, 0x3F, 0x00, 0x00, 0xFE, 0x01, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3F, 
  0x00, 0x00, 0xFE, 0x01, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3F, 0x00, 0x00, 
  0xFE, 0x01, 0x00, 0xFE, 0x07, 0x00, 0xC0, 0x3F, 0x00, 0x00, 0xFE, 0x01, 
  0x80, 0xFF, 0x3F, 0x00, 0xC0, 0x3F, 0x00, 0x00, 0xFE, 0x01, 0xE0, 0xFF, 
  0xFF, 0x01, 0xC0, 0x3F, 0x00, 0x00, 0xFE, 0x01, 0xF0, 0xFF, 0xFF, 0x07, 
  0xC0, 0x3F, 0x00, 0x00, 0xFE, 0x01, 0x3C, 0xF0, 0xFF, 0x07, 0xC0, 0x3F, 
  0x00, 0x00, 0xFE, 0x01, 0x06, 0x80, 0xFF, 0x03, 0xC0, 0x3F, 0x00, 0x00, 
  0xFE, 0x01, 0x07, 0x00, 0xFE, 0x01, 0xC0, 0x3F, 0x00, 0x00, 0xFE, 0x81, 
  0x1F, 0x00, 0x7E, 0x00, 0xC0, 0x3F, 0x00, 0x00, 0xFE, 0xC1, 0x3F, 0x00, 
  0x3E, 0x00, 0xC0, 0x3F, 0x00, 0x00, 0xFE, 0xC1, 0x0F, 0x00, 0x1E, 0x00, 
  0xC0, 0x7F, 0x00, 0x00, 0xFE, 0x81, 0x07, 0x00, 0x0F, 0x00, 0xC0, 0x7F, 
  0x00, 0x00, 0xFE, 0x03, 0x01, 0x80, 0x07, 0x00, 0xC0, 0x7F, 0x00, 0x00, 
  0xFE, 0x03, 0x00, 0xE0, 0x01, 0x00, 0xC0, 0x7F, 0x00, 0x00, 0xFE, 0x03, 
  0x00, 0xF0, 0x00, 0x00, 0x80, 0xFF, 0x00, 0x00, 0xFF, 0x01, 0x00, 0x78, 
  0x00, 0x00, 0x80, 0xFF, 0x01, 0x00, 0xFF, 0x00, 0x00, 0x3C, 0x00, 0x00, 
  0x80, 0xFF, 0x01, 0x00, 0x7F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x80, 0xFF, 
  0x03, 0x80, 0x1F, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0xFF, 0x0F, 0xC0, 
  0x0F, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0xFF, 0x3F, 0xF0, 0x03, 0x00, 
  0xE0, 0x01, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x01, 0x00, 0xF8, 0x01, 
  0x00, 0x18, 0x00, 0xFC, 0xFF, 0x7F, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x0F, 
  0x00, 0xFC, 0xFF, 0x3F, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0x00, 0xF8, 
  0xFF, 0x1F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xE0, 0xFF, 0x07, 
  0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x80, 0xFF, 0x03, 0x00, 0xC0, 
  0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xE0, 0xFF, 
  0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };

/**
 * Displaying options. 
 */
#define DISPLAY_MODE 10
#define REFRESH 1
#define MESSAGE 2
#define UPDATE_STATUS 3
#define UPDATE_ETA 4
#define UPDATE_PROGRESS 5
#define UPDATE_X 6
#define UPDATE_Y 7
#define UPDATE_Z 8
#define UPDATE_FEEDRATE 9

#define UPDATE_RED 12
#define UPDATE_GREEN 13
#define UPDATE_BLUE 14
#define UPDATE_BLINK 20

// LEDS
#define GREEN_LED A2
#define BLUE_LED A3
#define RED_LED A1

// RED Blinking
#define BLINK_REFRESH_INTERVAL 10
unsigned long lastBlinkRefresh = 0;
int blinker = 0;

// RPM counting
#define RPM_REFRESH_INTERVAL 1000
unsigned long lastRPMRefresh = 0;
long rpmCount = 0;

// Splash screen state
int displayOn = 0;
char* msg = "              waking up              ";              

// Dashboard state
int progress = 0;
int rpm = 0;
char* status = "BOOT------8";
char* x = "x-------1";
char* y = "y-------2";
char* z = "z-------3";
char* feedrate = "f--4";
char* rpmChar = "0       ";
char* eta = "             ";

void renderSplash(void) {
  u8g2.clearBuffer();

  u8g2.drawXBMP((128 - SPLASH_W)/2, 5, SPLASH_W, SPLASH_H, splash);

  u8g2.setFont(u8g2_font_5x8_tf);
  u8g2.drawStr((128-u8g2.getStrWidth(msg))/2, SPLASH_H+4, msg);

  u8g2.sendBuffer();
}

void renderDashboard(void) {
  u8g2.clearBuffer();
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);

  // Coord box  
  u8g2.drawFrame(0, 0, 80, 49);

  // Axis
  u8g2.setFont(u8g2_font_unifont_tf);
  u8g2.drawStr(4, 3, "X");
  u8g2.drawStr(4, 3+15, "Y");
  u8g2.drawStr(4, 3+15*2, "Z");

  // Coords
  u8g2.setFont(u8g2_font_unifont_tf);
  u8g2.drawStr(20, 3, x);
  u8g2.drawStr(20, 3+15, y);
  u8g2.drawStr(20, 3+15*2, z);

  // Status Code
  u8g2.drawBox(82, 0, 128-83, 16);
  u8g2.setDrawColor(0);
  u8g2.setFont(u8g2_font_unifont_tf);
  u8g2.drawStr(83 + (128-83- u8g2.getStrWidth(status)) /2, 1, status);
  u8g2.setDrawColor(1);

  if (progress != 0) { 
    // ETA
    u8g2.setFont(u8g2_font_5x8_tf);
    u8g2.drawStr(82, 33, eta);

    // Progress bar
    u8g2.drawFrame(82, 43, 45, 6);
    u8g2.drawBox(82, 43, map(progress, 0, 100, 0, 45), 6);
  }

  // Feedrate
  u8g2.setFont(u8g2_font_5x8_tf);
  u8g2.drawStr(82, 17, "F:");
  u8g2.drawStr(93, 17, feedrate);

  // FPM
  u8g2.setFont(u8g2_font_5x8_tf);
  u8g2.drawStr(82, 25, "S:");
  itoa(rpm, rpmChar, 10);
  u8g2.drawStr(93, 25, rpmChar);
  
  u8g2.setFont(u8g2_font_5x8_tf);
  u8g2.drawStr((128-u8g2.getStrWidth(msg))/2, 53, msg);

  u8g2.sendBuffer();
}

// update screen and state
void i2cEvent(int len);
void i2cRequest();
void count();
void draw();

void setup(void) {
  Wire.begin(77);  
  Wire.onReceive(i2cEvent);
  Wire.onRequest(i2cRequest);

  u8g2.begin();
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);

  pinMode(RED_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(BLUE_LED, OUTPUT);

  pinMode(2, INPUT);
  attachInterrupt(digitalPinToInterrupt(2), count, RISING);

  // boot splash screen
  renderSplash();
}

void loop(void) {
  // doing nothing
  unsigned long now = millis();

  if ((now - BLINK_REFRESH_INTERVAL) > lastBlinkRefresh) {
    lastBlinkRefresh = now;
    if (blinker!=0) {
       digitalWrite(RED_LED, true);
       blinker--;
       if(blinker==0){
            digitalWrite(RED_LED, false);
       }     
    }
  }

  if ((now - RPM_REFRESH_INTERVAL) > lastRPMRefresh) {
    lastRPMRefresh = now;

    rpm = rpmCount * 28;
    rpmCount = 0;       
  }
}

void draw(void) {
    if (displayOn == 1) {
        renderDashboard();
        return;
    }

    renderSplash();
}

void count() {
  rpmCount++;
}

int i2cResponse = 0;

void i2cEvent(int len)
{
    i2cResponse = 0;

    uint8_t data[len];
    Wire.readBytes(data, len);

    switch (data[0]) {
    case MESSAGE:
        memcpy(msg, &data[2], data[1]);
        break;

    case DISPLAY_MODE:
        displayOn = data[1];
        break;

    case UPDATE_PROGRESS:
        progress = data[1];
        break;
    
    case UPDATE_BLINK:
        blinker = data[1];
        break;

    case UPDATE_STATUS:
        memcpy(status, &data[2], data[1]);
        break;  

    case UPDATE_ETA:
        memcpy(eta, &data[2], data[1]);
        break;  

    case UPDATE_X:
        memcpy(x, &data[2], data[1]);
        break;  

    case UPDATE_Y:
        memcpy(y, &data[2], data[1]);
        break;  

    case UPDATE_Z:
        memcpy(z, &data[2], data[1]);
        break;  

    case UPDATE_FEEDRATE:
        memcpy(feedrate, &data[2], data[1]);
        break;  

   case UPDATE_RED:
        digitalWrite(RED_LED, data[1]==1);
        break;  

   case UPDATE_GREEN:
        digitalWrite(GREEN_LED, data[1]==1);
        break;  

   case UPDATE_BLUE:
        digitalWrite(BLUE_LED, data[1]==1);
        break;  

    case REFRESH:
        draw();
        break;  
    }

    i2cResponse = 1;
}

void i2cRequest()
{
    switch (i2cResponse) {
    case 0:
        Wire.write("er");
        break;
    case 1:
        Wire.write("ok");
        break;
    default:
        break;
    }

    i2cResponse = 0;
}